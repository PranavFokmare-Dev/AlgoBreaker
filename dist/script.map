{"version":3,"file":"script.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./src/background.js","webpack:///./src/popup.js"],"sourcesContent":["const analyticsEnum = {\r\n  NoTabSet: -1,\r\n  newTabUrl: \"chrome://newtab/\",\r\n  emptyUrl: \"EMPTY_URL\",\r\n  historyRemoverAlarmName: \"historyWeeklyRemover\",\r\n};\r\nconst webPage = {\r\n  homePage: \"#primary > ytd-rich-grid-renderer\",\r\n  videoPlayerEndScreen:\r\n    \"#movie_player > div.html5-endscreen.ytp-player-content.videowall-endscreen.ytp-show-tiles\",\r\n  videoPlayerSideContent: \"#items > ytd-item-section-renderer\",\r\n  search: \"#page-manager > ytd-search\",\r\n  playlistSideContent: \"#items > ytd-item-section-renderer\",\r\n  videoPlayerSideContent2: \"#secondary\",\r\n};\r\n\r\nlet currentWindowId = -1;\r\nlet windowSessions = {\r\n  //windowId -> {\r\n  // currentTabId : 1\r\n  // tabsessions : {\r\n  //    url: '',\r\n  //    startTime: number date.now(),\r\n  //  }\r\n  //}\r\n};\r\n\r\nchrome.runtime.onInstalled.addListener(async () => {\r\n  chrome.storage.sync.set({ mode: \"on\" }, function () {});\r\n  console.log(\"runtime on installed\");\r\n  await setInStorage({ mode: \"on\" });\r\n  await saveHistory({});\r\n  const weekDurationInMins = 7 * 24 * 60;\r\n  chrome.alarms.create(analyticsEnum.historyRemoverAlarmName, {\r\n    periodInMinutes: weekDurationInMins,\r\n  });\r\n});\r\n\r\n//Button click -> on/off call\r\nchrome.runtime.onMessage.addListener(async function (\r\n  request,\r\n  sender,\r\n  sendResponse\r\n) {\r\n  AlgoBreakerMain(request.mode, request.tabId, request.tabUrl);\r\n\r\n  console.log(\"SUMMARY\");\r\n  console.log(currentWindowId);\r\n  console.log(windowSessions);\r\n  console.log(await getHistory());\r\n});\r\n\r\n//Change in URL|tab created changed url\r\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\r\n  chrome.storage.sync.get([\"mode\"], function (result) {\r\n    const mode = result.mode;\r\n    AlgoBreakerMain(mode, tab.id, tab.url);\r\n  });\r\n});\r\n\r\nfunction AlgoBreakerMain(mode, tabId, url) {\r\n  if (mode === \"on\") AlgoBreakerOn(url, tabId);\r\n  else AlgoBreakerOff(tabId);\r\n}\r\n\r\nfunction AlgoBreakerOn(url, tabId) {\r\n  const hideCss = `${webPage.homePage}{visibility:hidden}\r\n${webPage.videoPlayerEndScreen}{visibility:hidden}\r\n${webPage.videoPlayerSideContent}{visibility:hidden}\r\n${webPage.playlistSideContent}{visibility:hidden}\r\n${webPage.videoPlayerSideContent2}{visibility:hidden}\r\n${webPage.amazonPrimeAutoPlay2}{visibility:hidden}\r\n`;\r\n  // adding if url starts with\r\n  // adding show css if the url doesnt starts with\r\n  chrome.scripting.insertCSS(\r\n    {\r\n      target: { tabId: tabId },\r\n      css: hideCss,\r\n    },\r\n    () => {}\r\n  );\r\n}\r\n\r\nfunction AlgoBreakerOff(tabId) {\r\n  const showCss = `${webPage.homePage}{visibility:visible}\r\n  ${webPage.videoPlayerEndScreen}{visibility:visible}\r\n  ${webPage.videoPlayerSideContent}{visibility:visible}\r\n  ${webPage.playlistSideContent}{visibility:visible}\r\n  ${webPage.videoPlayerSideContent2}{visibility:visible}\r\n  ${webPage.amazonPrimeAutoPlay2}{visibility:visible}\r\n  `;\r\n  chrome.scripting.insertCSS(\r\n    {\r\n      target: { tabId: tabId },\r\n      css: showCss,\r\n    },\r\n    () => {}\r\n  );\r\n}\r\n\r\n//Analytics code\r\nchrome.windows.onFocusChanged.addListener(async function (newWindowId) {\r\n  console.log(\"window focus changed\" + newWindowId);\r\n  if (isBrowserNotInFocus(newWindowId) && windowSessionExists(newWindowId)) {\r\n    await endSession(windowSessions[newWindowId].currentTabId, newWindowId);\r\n  } else if (isExistingBrowserWindow(newWindowId)) {\r\n    startSessionForActiveTabIn(newWindowId);\r\n    if (isExistingBrowserWindow(currentWindowId)) {\r\n      await endSession(getActiveTabInWindow(currentWindowId), currentWindowId);\r\n    }\r\n    if (newWindowId != -1) {\r\n      currentWindowId = newWindowId;\r\n      console.log(\"CURRENT WINDOW ID Changed to \", currentWindowId);\r\n    }\r\n  } else {\r\n    if (newWindowId != -1) {\r\n      currentWindowId = newWindowId;\r\n      console.log(\"CURRENT WINDOW ID Changed to \", currentWindowId);\r\n    }\r\n  }\r\n  function isBrowserNotInFocus(windowId) {\r\n    return windowId == -1;\r\n  }\r\n  function windowSessionExists(windowId) {\r\n    return windowSessions[windowId] !== undefined;\r\n  }\r\n  function isExistingBrowserWindow(newWindowId) {\r\n    return windowSessions[newWindowId] !== undefined;\r\n  }\r\n  function startSessionForActiveTabIn(windowId) {\r\n    let windowSession = windowSessions[windowId];\r\n    const activeTabId = windowSession.currentTabId;\r\n    const tabSessions = windowSession.tabSessions;\r\n    tabSessions[activeTabId].startTime = Date.now();\r\n    console.log(\r\n      `In the window ID ${windowId} for tab ${activeTabId} for Url ${tabSessions[activeTabId].url} started the session`\r\n    );\r\n  }\r\n  function getActiveTabInWindow(windowId) {\r\n    const windowSession = windowSessions[windowId];\r\n    return windowSession.currentTabId;\r\n  }\r\n});\r\nasync function endSession(tabId, windowId) {\r\n  let tabSessions = windowSessions[windowId].tabSessions;\r\n  const session = tabSessions[tabId];\r\n  const timeSpent = getTimeSpent(session);\r\n  await updateHistory();\r\n  session.startTime = 0;\r\n\r\n  function getTimeSpent(session) {\r\n    if (session.startTime === 0) return 0;\r\n    return Date.now() - session.startTime;\r\n  }\r\n  async function updateHistory() {\r\n    let history = await getHistory();\r\n    if (history[session.url] === undefined) {\r\n      history[session.url] = 0;\r\n    }\r\n    history[session.url] += Math.max(timeSpent, 0);\r\n    await saveHistory(history);\r\n  }\r\n}\r\nchrome.tabs.onActivated.addListener(async function (activeInfo) {\r\n  console.log(\"Active\" + activeInfo.tabId);\r\n  let tabId = activeInfo.tabId;\r\n  let windowId = activeInfo.windowId;\r\n  let windowSession = getOrCreateWindowSession(windowId);\r\n  let currentTabId = windowSession.currentTabId;\r\n  currentWindowId = windowId;\r\n  const tabSessions = windowSession.tabSessions;\r\n\r\n  await endOldSession(currentTabId, windowId);\r\n  currentTabId = tabId;\r\n  windowSession.currentTabId = tabId;\r\n  const isOldTab = tabSessions[tabId] !== undefined;\r\n  if (isOldTab) {\r\n    tabSessions[tabId].startTime = Date.now();\r\n  } else {\r\n    tabSessions[tabId] = {\r\n      url: analyticsEnum.emptyUrl,\r\n      startTime: 0,\r\n      endTime: 0,\r\n    };\r\n  }\r\n\r\n  async function endOldSession(currentTabId, windowId) {\r\n    if (currentTabId !== analyticsEnum.NoTabSet) {\r\n      await endSession(currentTabId, windowId);\r\n    }\r\n  }\r\n});\r\n\r\nfunction getOrCreateWindowSession(windowId) {\r\n  if (windowSessions[windowId] === undefined) {\r\n    windowSessions[windowId] = {\r\n      currentTabId: -1,\r\n      tabSessions: {},\r\n    };\r\n  }\r\n  return windowSessions[windowId];\r\n}\r\n\r\nchrome.tabs.onUpdated.addListener(async function (tabId, changeInfo, tab) {\r\n  const notUpdatedToNewTab = tab.url != analyticsEnum.newTabUrl;\r\n\r\n  console.log(\"update\" + tabId);\r\n  let windowId = tab.windowId;\r\n  let window = getOrCreateWindowSession(windowId);\r\n  let tabSessions = window.tabSessions;\r\n  let currentTabId = window.currentTabId;\r\n\r\n  if (notUpdatedToNewTab) {\r\n    await handleTabLoadedEvent();\r\n  }\r\n\r\n  async function handleTabLoadedEvent() {\r\n    const tabExists = tabSessions[tabId] !== undefined;\r\n    if (tabExists) {\r\n      const isLinkUpdatedFromNewTab =\r\n        tabSessions[tabId].url === analyticsEnum.emptyUrl;\r\n      if (isLinkUpdatedFromNewTab) {\r\n        initializeSession();\r\n      } else {\r\n        //In current tab user changed the link\r\n        await updateSessionToNewLink();\r\n      }\r\n    } else {\r\n      //middle click\r\n      initalizeInactiveSession();\r\n    }\r\n  }\r\n\r\n  function initializeSession() {\r\n    tabSessions[tabId].url = getHostName(tab.url);\r\n    tabSessions[tabId].startTime = Date.now();\r\n  }\r\n\r\n  async function updateSessionToNewLink() {\r\n    if (tabId === currentTabId) {\r\n      await endSession(tabId, windowId);\r\n      tabSessions[tabId] = {\r\n        url: getHostName(tab.url),\r\n        startTime: Date.now(),\r\n        endTime: 0,\r\n      };\r\n    }\r\n  }\r\n\r\n  function initalizeInactiveSession() {\r\n    console.log(\"middle click\");\r\n    console.log(tab);\r\n    tabSessions[tabId] = {\r\n      url: getHostName(tab.url),\r\n      startTime: 0,\r\n      endTime: 0,\r\n    };\r\n  }\r\n});\r\nasync function endTabSession(tabId) {\r\n  const session = tabSessions[tabId];\r\n  const timeSpent = Date.now() - session.startTime;\r\n  await updateHistory();\r\n  session.startTime = 0;\r\n\r\n  async function updateHistory() {\r\n    let history = await getHistory();\r\n    if (history[session.url] === undefined) {\r\n      history[session.url] = 0;\r\n    }\r\n    history[session.url] += Math.max(timeSpent, 0);\r\n    await saveHistory(history);\r\n  }\r\n}\r\n\r\nchrome.tabs.onRemoved.addListener(async function (closingTabID, removedInfo) {\r\n  console.log(\"closed\" + closingTabID);\r\n  const windowId = removedInfo.windowId;\r\n  const window = windowSessions[windowId];\r\n  if (window != undefined) {\r\n    const tabSessions = window.tabSessions;\r\n    let currentTabId = window.currentTabId;\r\n\r\n    const tabExists = tabSessions[closingTabID] !== undefined;\r\n    if (tabExists) {\r\n      if (closingCurrentTab(closingTabID, currentTabId))\r\n        await endSession(closingTabID, windowId);\r\n      delete tabSessions[closingTabID];\r\n    }\r\n  }\r\n\r\n  function closingCurrentTab(closingTabID, currentTabId) {\r\n    return closingTabID === currentTabId;\r\n  }\r\n});\r\n\r\nasync function getHistory() {\r\n  let history = await getFromStorage(\"history\");\r\n  return history === undefined ? {} : history;\r\n}\r\n\r\nasync function saveHistory(history) {\r\n  await setInStorage({ history: history });\r\n}\r\n\r\nfunction getFromStorage(key) {\r\n  return new Promise((resolve, reject) => {\r\n    chrome.storage.sync.get([key], function (result) {\r\n      const value = result[key];\r\n      if (chrome.runtime.lastError) {\r\n        console.log(\"error occured\" + chrome.runtime.error);\r\n      } else {\r\n        resolve(value);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction setInStorage(data) {\r\n  return new Promise((resolve, reject) => {\r\n    chrome.storage.sync.set(data, function () {\r\n      resolve();\r\n    });\r\n  });\r\n}\r\n\r\nfunction getTabInfo(tabId) {\r\n  return new Promise((resolve, reject) => {\r\n    chrome.tabs.get(tabId, function (tab) {\r\n      resolve(tab);\r\n    });\r\n  });\r\n}\r\n\r\nfunction getHostName(url) {\r\n  const details = new URL(url);\r\n  return details.hostname;\r\n}\r\n\r\n// history remover\r\nchrome.alarms.onAlarm.addListener(async function (alarm) {\r\n  if (alarm.name === analyticsEnum.historyRemoverAlarmName) {\r\n    console.log(\"removing History\");\r\n    await saveHistory({});\r\n  }\r\n});\r\n","let button = document.getElementById(\"changeColor\");\r\n\r\nbutton.addEventListener(\"click\", async () => {\r\n  let [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\r\n\r\n  chrome.storage.sync.get([\"mode\"], function (result) {\r\n    const mode = result.mode;\r\n    const toggledMode = mode === \"on\" ? \"off\" : \"on\";\r\n    button.innerHTML = `Turn it ${mode}`;\r\n    chrome.storage.sync.set({ mode: toggledMode }, function () {\r\n      chrome.runtime.sendMessage(\r\n        { tabId: tab.id, tabUrl: tab.url, mode: toggledMode },\r\n        function (response) {}\r\n      );\r\n    });\r\n  });\r\n});\r\n\r\nfunction getURL() {}\r\n"],"names":[],"sourceRoot":""}